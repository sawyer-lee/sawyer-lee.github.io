<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CGI，FastCGI以及PHP的实现</title>
      <link href="/2019/02/25/CGI-FastCGI-And-PHP/"/>
      <url>/2019/02/25/CGI-FastCGI-And-PHP/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是CGI："><a href="#什么是CGI：" class="headerlink" title="什么是CGI："></a>什么是CGI：</h1><p>&emsp;&emsp;通用网关接口，是WebServer和外部程序之间的通讯协议。早期的WebServer是只处理静态内容的，但是随着WWW的发展交互性要求越来越强，出现了各种动态处理语言实现复杂的功能。Web端的业务逻辑越来越复杂将这些都交给WebServer处理不现实，而且各种编程语言各自独立且有各自的知识产权，因此就出现了CGI协议，它使WebServers把复杂的逻辑交给各编程语言。</p><p>&emsp;&emsp;CGI的好处就是使WebServer完全独立于语言，仅仅是做为中间接口协议，链接WebServer和外部程序。他们通过cgi搭线来完成数据传递。这样做的好处是尽量减少2个的关联，使他们2变得更独立。CGI可以用任何编程语言编写，只要这种语言具有标准输入、输出和环境变量，例如：perl、PHP等。事实上第一个CGI实现就是用Perl[‘pə:l]写的。</p><h2 id="原理流程："><a href="#原理流程：" class="headerlink" title="原理流程："></a>原理流程：</h2><ul><li>1、客户端访问一个地址，通过HTTP协议发送请求（GET/POST/PUT/DELTE etc.）给WebServer。</li><li>2、WebServer会Fork一个子进程，将请求描述信息通过标准输入STDIN和环境变量传给CGI程序。</li><li>3、启动CGI外部程序处理请求，处理结果通过标准输出STDOUT返回给WebServer子进程，并结束和销毁相关资源。</li><li>4、有WebServer子进程通过HTTP协议将数据返回给客户端。</li><li>5、通常Web服务器使用*unix Shell环境变量来保存参数和环境变量。</li></ul><p><img src="/img/2018-02/cgi.jpg" alt="&quot;流程图如图示&quot;"></p><h2 id="CGI有个致命的弱点："><a href="#CGI有个致命的弱点：" class="headerlink" title="CGI有个致命的弱点："></a>CGI有个致命的弱点：</h2><p>每一个请求都会fork一个CGI进程处理，也就是最为人诟病的Fork-And-Execute模式，所以性能低下。</p><h1 id="什么是FastCGI"><a href="#什么是FastCGI" class="headerlink" title="什么是FastCGI:"></a>什么是FastCGI:</h1><p>&emsp;&emsp;FastCGI是Web服务器和处理程序之间通信的一种协议， 是CGI的一种改进方案，FastCGI像是一个常驻(long-lived)型的CGI， 它可以一直执行，在请求到达时不会花费时间去fork一个进程来处理(这是CGI最为人诟病的fork-and-execute模式)。 因为是通信协议可以通过Socket通讯，所以它还支持分布式的运算， FastCGI 程序可以在网站服务器以外的主机上执行，并且可以接受来自其它网站服务器的请求。FastCGI 是与语言无关的、可伸缩架构的 CGI 开放扩展，主要特点是将 CGI 解释器进程保持在内存中，不需要反复fork，以此获得较高的性能。 CGI 程序反复加载是CGI性能低下的主要原因，如果 CGI 程序保持在内存中并接受 FastCGI 进程管理器调度， 则可以提供良好的性能、伸缩性、Fail-Over 特性等。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li>1.WebServer启动时载入FastCGI进程管理器，IIS的ISAPI，Apache的Mod_PHP，Nginx借助PHP-FPM</li><li>2.FastCGI进程管理器自身初始化（解析PHP.ini以及环境变量等），启动多个子进程/CGI解析器，等待webServer的链接。</li><li>3.客户端请求到达Web Server时，FastCGI解释器选择并链接到一个子进程(PHP-FPM或PHP-CGI)，将标准输入和环境变量发送给子进程。</li><li>4.FastCGI子进程处理后将标准输出和错误信息从同一连接返回WebServer，当FastCGI子进程关闭连接时 请求处理便完成了。</li><li>5.CGI下这时进程退出了，但是FastCGI该子进程会继续运行并等待下一个连接请求。<br>  CGI中每一个请求，PHP都必须重新初始化PHP.ini，载入扩展或者dll并重初始化所有环境变量等。<br>  FastCGI只有在进程启动时做一次，之后便一直运行，这有另外一个好处就是可以使用外部数据的长连接模式。</li></ul><h1 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI:"></a>PHP-CGI:</h1><p>&emsp;&emsp;PHP-CGI是php官方出品的fastcgi管理器，不支持平滑重启，改了php.ini就要kill掉原来的php-cgi再重新启动才能生效；不支持动态worker调度，只能一开始指定要起几个worker。</p><h1 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM:"></a>PHP-FPM:</h1><p>&emsp;&emsp;FPM(FastCGI Process Manager)是PHP FastCGI运行模式的一个进程管理器，但是在早期他只是是PHP的一个扩展，PHP 5.3.3合并到主分支。加入了动态调度功能，可以根据请求来访压力变化动态增减worker进程数量；支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置。另外像Apache的mod_fcgid和IIS的PHP Manager需要调用php-cgi进程, 但php-fpm则根本不依赖php-cgi,完全独立运行,也不依赖php(cli)命令行解释器. 因为php-fpm是一个内置了php解释器的FastCGI服务,启动时能够自行读取php.ini配置和php-fpm.conf配置. </p><p>&emsp;&emsp;FPM的核心功能是进程管理，那么它用来管理什么进程呢？这个就需要从FastCGI说起了。FastCGI前面有详细的介绍了，注意：它只是一种协议！PHP是一个脚本解析器，你可以把它理解为一个普通的函数，输入是PHP脚本；输出是执行结果，相对于WebServer来说他就是一个外部程序处理动态请求。</p><p>&emsp;&emsp;在网络应用场景下，PHP需要接收请求、解析协议，然后处理完成返回请求，然而PHP并没有像Golang那样实现http网络库，而是实现了FastCGI协议，然后与web服务器配合实现http的处理。借助于web服务器来解析http请求，然后将解析的结果再通过FastCGI协议转发给PHP处理程序，PHP处理完成后将结果返回给web服务器，web服务器再返回给用户。</p><p><img src="/img/2018-02/fastcgi.png" alt="&quot;FastCGI流程图如图示&quot;"></p><p>通常程序处理模型有两种：多进程、多线程。</p><p>&emsp;&emsp;PHP本身不支持多线程，要实现多线程需要借助于其他第三方扩展来实现，对于PHP来说通常采用多进程模型。多进程模型通常是主进程只负责管理子进程，而基本事件由各个子进程处理，nginx、fpm就是这种模式；另一种多线程模型与多进程类似，只是它是线程粒度，通常会由主线程监听、接收请求，然后交由子线程处理，例如，Java，C++等都是支持多线程的。</p><p>&emsp;&emsp;概括来说，fpm就是创建一个master进程，在master进程中创建并监听socket，然后fork出多个子进程，这些子进程各自accept请求，子进程的处理非常简单，它在启动后阻塞在accept上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说fpm的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求，这一点与nginx的事件驱动有很大的区别，nginx的子进程通过epoll管理套接字，如果一个请求数据还未发送完成则会处理下一个请求，即一个进程会同时连接多个请求，它是非阻塞的模型，只处理活跃的套接字。master进程不处理请求，只负责进程管理、异步事件和定时器事件处理。</p><p>fpm可以同时监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程，类似nginx中server概念，一个pool对应一个nginx的站点，这样可以提高安全，如同站点切割。</p><p><img src="/img/2018-02/worker_pool.png" alt="&quot;PHP-FPM Worker Poll&quot;"></p><p>在php-fpm.conf中通过[pool name]声明一个worker pool：<br><pre><code>[web1]listen = 127.0.0.1:9000...[web2]listen = 127.0.0.1:9001...启动fpm后查看进程：ps -aux|grep fpmroot     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</code></pre></p><p>&emsp;&emsp;PHP-FPM的master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等。当master进程要杀掉一个worker进程时则通过发送信号的方式通知worker进程。</p><p>&emsp;&emsp;每个worker进程都内置PHP解释器并且进程常驻后台，支持prefork动态增加，支持在运行时编译脚本，并在内存中缓存生成的opcode来提升性能。每个worker进程支持配置响应指定请求数后自动重启，master进程会重启挂掉的worker进程。</p><p>&emsp;&emsp;因为常驻内存特性worker进程能保持一个到MySQL/Memcached/Redis的持久连接实现”连接池”，避免重复建立连接对程序透明，但是注意：<strong><em> 使用数据库持久连接时应该设置固定数量的worker进程数,不要使用动态的prefork模式。且进程数不要超过资源的最大连接数，否则连接数用尽程序将不可用。</em></strong> PHP-FPM管理worker有三种模式：static，dynamic，ondemand：</p><ul><li>static模式下配置固定数量的worker；</li><li>dynamic模式下根据配置启动初始worker数量，按照运行情况动态prefork一组，直到最大数量max_children，如果此时所有worker繁忙master进程会把请求挂起到连接队列backlog里(默认值是511).。</li><li>ondemand模式下没有初始worker运行，当请求来了创建worker，处理请求完成后保持worker不退出，直到达到配置的超时时间被主进程关闭。</li></ul><p>参考：<br>FPM的架构：<a href="https://www.cnblogs.com/huanxiyun/articles/5413755.html" target="_blank" rel="noopener">https://www.cnblogs.com/huanxiyun/articles/5413755.html</a><br>PHP内核：<a href="https://github.com/pangudashu/php7-internal/blob/master/1/fpm.md" target="_blank" rel="noopener">https://github.com/pangudashu/php7-internal/blob/master/1/fpm.md</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CGI </tag>
            
            <tag> FastCGI </tag>
            
            <tag> PHP-FPM </tag>
            
            <tag> PHP-CGI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top和strace 查看某些或者某个进程</title>
      <link href="/2017/12/28/Top-commond-and-trace/"/>
      <url>/2017/12/28/Top-commond-and-trace/</url>
      
        <content type="html"><![CDATA[<p>Top 查看某些或者某个进程（top -p pid）</p><p>top中使用CPU或MEM排序，还是看不到我们想了解的进程的相关信息；这时就可以指定对某个或某些进程进行TOP信息显示；</p><p>1、查看某个进程的信息<br>例：mysqld的信息<br>(1)得到mysqld进程的pid<br>[root@6 ~]# pidof mysqld<br>21538</p><p>(2)top指定查看PID<br>[root@6 ~]# top -p 21538</p><p>top - 09:15:06 up 30 days, 53 min,  3 users,  load average: 0.07, 0.22, 0.23<br>Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie<br>Cpu(s):  3.0%us,  6.9%sy,  0.2%ni, 89.4%id,  0.3%wa,  0.1%hi,  0.1%si,  0.0%st<br>Mem:   1035140k total,   994888k used,    40252k free,   383072k buffers<br>Swap:  2048248k total,       80k used,  2048168k free,   237456k cached</p><p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>21538 mysql     15   0  146m  21m 4372 S  0.0  2.1   3:03.84 mysqld</p><p>2、查看某些进程的信息<br>例：mysqld/httpd的信息<br>(1)得到mysqld/httpd进程的pid<br>[root@6 ~]# pidof mysqld<br>21538</p><p>[root@6 ~]# pidof httpd<br>31117 31116 31115 31114</p><p>(2)top指定查看PID<br>[root@6 ~]# top -p 21538,31117,31116,31115,31114</p><p>top - 09:20:05 up 30 days, 58 min,  3 users,  load average: 0.37, 0.24, 0.23<br>Tasks:   5 total,   0 running,   5 sleeping,   0 stopped,   0 zombie<br>Cpu(s):  3.0%us,  6.9%sy,  0.2%ni, 89.4%id,  0.3%wa,  0.1%hi,  0.1%si,  0.0%st<br>Mem:   1035140k total,   994364k used,    40776k free,   383404k buffers<br>Swap:  2048248k total,       80k used,  2048168k free,   237560k cached</p><p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>21538 mysql     15   0  146m  21m 4372 S  0.0  2.1   3:03.86 mysqld<br>31117 apache    15   0 60036 8428 4668 S  0.0  0.8   0:00.48 httpd<br>31116 apache    15   0 60308 9.9m 6288 S  0.0  1.0   0:00.48 httpd<br>31115 apache    15   0 60100 8552 4756 S  0.0  0.8   0:00.48 httpd<br>31114 apache    15   0 59892 6452 3060 S  0.0  0.6   0:00.41 httpd </p><p>linux下用来跟踪某个进程的系统调用。<br>sudo strace -p 21538</p><ul><li>在solaris下，对应的是dtrace。</li><li>在mac下，对应的命令是：dtruss。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
            <tag> Top </tag>
            
            <tag> strace </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用自增主键无数遍，但你真懂InnoDB自增吗？</title>
      <link href="/2017/12/28/mysql-auto-increment/"/>
      <url>/2017/12/28/mysql-auto-increment/</url>
      
        <content type="html"><![CDATA[<p>在一次宕机之后重启Mysql服务器并恢复数据的过程中发现了自增主键列的自增数值会回退，导致有数据上有冲突。<br>经过一番的排查之后发现了一个非常容易被忽略的事实，Mysql中自增ID的值在一定条件下会回退！因此导致自增主键有重复导，外键关联失效引起。</p><p>我们来举个例子说明一下具体的现象：<br>例如，创建一个个InNoDB引擎表:<br><pre><code>CREATE TABLE `bsession`  (    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,    `aname` varchar(80) NOT NULL DEFAULT ‘’,    PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</code></pre></p><p>创建数据表之后，我们来插入一些数据来重现一下效果，插入 10条数据，<br><pre><code>INSERT INTO `bsession` (aname) values (&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a’);</code></pre></p><p>接下来，再删除最后的几条数据，看看id的变化是怎样的，<br><pre><code>DELETE FROM bsession where id in (8,9,10);</code></pre></p><p><img src="/img/2017-12-28/mysql_innodb_auto_increment1.jpg" alt="&quot;更新数据后数据变化情况&quot;"></p><p>在删除部分数据之后表中的仅有7条，且最大的’id’ = 7, 现在进行数据库重启，并重新插入10条数据，我们验证一下自增列从8还是11开始自增计数，<br>看下图的数据变化，注意：id列的增长情况</p><p><img src="/img/2017-12-28/mysql_innodb_auto_increment2.jpg" alt="&quot;更新数据后数据变化情况&quot;"></p><p> 结果事实证明，自增列 id 的值出现了回滚，不是从11开始计数生成新纪录，而是继续了表中最大id，从8开始计数。<br> 说到这里肯定有人要问了是什么原因导致 自增属性字段，在重启后会回退呢？<br> 根据现象猜测大致原因如下：<br> <em>InNoDB的存储引擎是将AUTO_INCREMENT计数器的累计值存放到主内存中的; </em>大概是为了计数器的频繁跟新，为了保证速速并非存入硬盘文件，<br> *因为内存存储，当重启后内存数据就丢失了，启动后计数器的值只好从表中MAX(自增字段)来获取当前最大计数器值</p><p>要了解真实的原因以及进一步确认MySql的InnoDB引擎是如何处理自增列的，翻看查看官方文档找到了如下内容：<br><blockquote><p><img src="/img/2017-12-28/mysql_innodb_auto_increment3.jpg" alt="&quot;更新数据后数据变化情况&quot;"></p><footer><strong>AUTO_INCREMENT Handling in InnoDB</strong><cite><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">MySQL 5.7 Reference Manual</a></cite></footer></blockquote></p><p>查阅了不同版本的官方手册确认了截止Mysql 5.7 所有版本都存在这个问题，不过这个特性将在Mysql的下一个版本8.0中更改。<br>自增计数器每次更改时，当前的最大自增计数器值将会被写入redo log中，并保存到InnoDB引擎的私有系统表中，记录到每个检查点， 实现自增计数器的持久化，重启后值会保持一致。</p><p>当服器在Crash中恢复后，重启过程中InnoDB使用存储在系统字典表里的当前最大自增，并且从最后一个检查点开始扫描RedoLog中的计数器值。如果Redo Log中的值大于内存中的计数器值，Redo Log中的值将会被采用。</p><p>关于后续版本中对于 自增列的处理机制的更详细说明，请查看官方文档，这里不在赘述。<br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html" title="[external] [MySQL 8.0 Reference Manual]" target="_blank" rel="noopener">InnoDB AUTO_INCREMENT Lock Modes</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
            <tag> auto_increment </tag>
            
            <tag> 自增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IT从业人的职业规划</title>
      <link href="/2017/12/28/IT%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
      <url>/2017/12/28/IT%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当你对某种技能已经有了一定的了解，开始觉得自己如同“行尸走肉”，成为一个开发工具的时候，那就应该要明确一下自己的发展方向了。</p><footer><strong>某位技术大牛</strong><cite>Sawyer.Lee</cite></footer></blockquote><h1 id="从大的方向来说基本三个大方向"><a href="#从大的方向来说基本三个大方向" class="headerlink" title="从大的方向来说基本三个大方向"></a>从大的方向来说基本三个大方向</h1><h2 id="单方面技术发展方向："><a href="#单方面技术发展方向：" class="headerlink" title="单方面技术发展方向："></a>单方面技术发展方向：</h2><ul><li><p>技术大牛方向：<br>1、精通PHP,Python,Java等语言特性，正确的使用各种语法、各种函数，编码规范、已读。<br>2、灵活运用各种数据类型，深入了解和应用语言数据结构、DB、NO-SQL。<br>3、正确合理的实现控制逻辑、更好地算法实现。</p></li><li><p>架构师方向:<br>1、真正去理解OOD、OOP思想并在实际开发工作中充分应用OO的设计、编码方法；<br>2、提高代码封装度(隔离保护，安全、降低复杂度，高复用好维护)、多态性(更好的维护性，更通用)、继承（更高的复用性扩展性）、<br>3、功能模块化、组件化、自动化、工具配置化。<br>4、很好的数据处理、高并发设计、大压力系统设计和优化。</p></li><li><p>技术专家方向：<br>1、设计优化框架，公共库组件、模块；成熟的业务模型解决方案。<br>2、吃透核心原理、WebServer运行原理、WebServer与PHP的通信原理等深入机制理解透彻，各种深度扩展，最大化发挥效率。<br>3、熟悉C并灵活运用可以写PHP扩展，定制化扩展和组件。</p></li></ul><h2 id="从技术向业务方向过渡。"><a href="#从技术向业务方向过渡。" class="headerlink" title="从技术向业务方向过渡。"></a>从技术向业务方向过渡。</h2><ul><li><p>第一个层级：<br>1、扎实的技术基础知识（HTML、CSS、JS、PS切图、UI、程序逻辑、数据库、程序体系结构）。<br>2、了解各种业务模型、各种行业业务流程，大致的开发流程、关键技术点、工作量（电商、游戏、金融、支付、App）。<br>3、最重要的沟通能力、业务理解能力、可以做好产品需求与开发人员的桥梁，熟悉项目管理。</p></li><li><p>第二层级：<br>1、较丰富的开发经验、了解各种开发语言以及特性、大用户高并发大数据系统经验，系统集成经验。<br>2、精通各种业务模型、数据统计方式、统计数据意义和价值、工作量的把握，业务拆分质量、验收、评估监督等。<br>3、很好的项目管理能力，理解能力极强，可沟通协调解决各种资源冲突、成本管理、风险管理等等，了解项目组人员性格量材分配。</p></li><li><p>第三个层级：<br>1、丰富的开发经验、熟悉各种开发语言以及特性、大用户高并发大数据系统经验，系统集成经验，熟悉各种解决方案。<br>2、业务把控能力、需求把关审核、深入了解各种业务模块、了解行业特性、竞争者情况并作出相应的决策。<br>3、管理多个项目组，hold住各种任务、各种部门和团队沟通协调、高级项目管理能力，PMP, 3Sigma, 6Sigma, CPM, TOGAF 等等。</p></li><li><p>第四个层级：<br>AVP/VP/FVP/GM….CEO…</p></li></ul><h2 id="从程序员向技术管理方向过渡。"><a href="#从程序员向技术管理方向过渡。" class="headerlink" title="从程序员向技术管理方向过渡。"></a>从程序员向技术管理方向过渡。</h2><ul><li>技术TL、很好的技术能力、能带新人、可以解决小组各种问题、性能优化、系统整合，核心业务开发。</li><li>技术TM/EM，团队管理、技术方案、很好的技术能力、丰富开发经验、大系统经验、架构、框架等等….</li><li>技术TD/ED，部门管理、研发团队管理、基层技术方案设计、技术方向把关、新技术研究应用、技术方案决策。</li><li>CTO/CIO…</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IT行业 </tag>
            
            <tag> 职业规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Redis管道提升批量操作性能</title>
      <link href="/2017/02/20/Redis%E7%AE%A1%E9%81%93%E6%8F%90%E5%8D%87%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD/"/>
      <url>/2017/02/20/Redis%E7%AE%A1%E9%81%93%E6%8F%90%E5%8D%87%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol><li>最近在工作中使用了Redis的管道技术。</li><li>发现对于互不相关的多次Redis操作使用管道可以极大的提升性能。</li><li>特此记录。</li></ol><h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><ol><li>个人觉得问题可能出在TCP连接上。</li><li>Redis使用TCP协议进行数据传输，在多次Redis命令中会有大量的时间消耗在TCP握手上。</li><li>而管道可以合并多次TCP请求，统一发送，这样就可以节省大量的时间。</li></ol><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="初始化Redis连接"><a href="#初始化Redis连接" class="headerlink" title="初始化Redis连接"></a>初始化Redis连接</h2><ol><li>使用phpredis扩展，初始化Redis连接。</li><li>代码略。</li></ol><h2 id="获取毫秒数时间"><a href="#获取毫秒数时间" class="headerlink" title="获取毫秒数时间"></a>获取毫秒数时间</h2><pre><code>1. function getMillisecond() { 2.     list($s1, $s2) = explode(&#39; &#39;, microtime()); 3.     return (float)sprintf(&#39;%.0f&#39;, (floatval($s1) + floatval($s2)) * 1000); 4. } </code></pre><h2 id="不使用事务-代码段："><a href="#不使用事务-代码段：" class="headerlink" title="不使用事务 代码段："></a>不使用事务 代码段：</h2><pre><code>1. $sTime = getMillisecond();2. for ($i = 0; $i &lt; 10000; $i++) {3.     $this-&gt;redis-&gt;set(&#39;Test:test&#39; . $i,&#39;test&#39;);4. }5. $eTime = getMillisecond();6. var_dump($eTime - $sTime);</code></pre><h2 id="结果（多次）："><a href="#结果（多次）：" class="headerlink" title="结果（多次）："></a>结果（多次）：</h2><ol><li>float(3199)</li><li>float(3145)</li><li>float(3436)</li></ol><h2 id="使用参数为MULTI的一般事务-代码段："><a href="#使用参数为MULTI的一般事务-代码段：" class="headerlink" title="使用参数为MULTI的一般事务 代码段："></a>使用参数为MULTI的一般事务 代码段：</h2><pre><code>1. $sTime = getMillisecond();2. $this-&gt;redis-&gt;multi(Redis::MULTI);3. for ($i = 0; $i &lt; 10000; $i++) {4.     $this-&gt;redis-&gt;set(&#39;Test:test&#39; . $i,&#39;test&#39;);5. }6. $this-&gt;redis-&gt;exec();7. $eTime = getMillisecond();8. var_dump($eTime - $sTime);</code></pre><h2 id="结果（多次）：-1"><a href="#结果（多次）：-1" class="headerlink" title="结果（多次）："></a>结果（多次）：</h2><ol><li>float(3160)</li><li>float(3410)</li><li>float(3093)</li></ol><h2 id="使用参数为PIPELINE的管道事务-代码段："><a href="#使用参数为PIPELINE的管道事务-代码段：" class="headerlink" title="使用参数为PIPELINE的管道事务 代码段："></a>使用参数为PIPELINE的管道事务 代码段：</h2><pre><code>1. $sTime = getMillisecond();2. $this-&gt;redis-&gt;multi(Redis::PIPELINE);3. for ($i = 0; $i &lt; 10000; $i++) {4.     $this-&gt;redis-&gt;set(&#39;Test:test&#39; . $i,&#39;test&#39;);5. }6. $this-&gt;redis-&gt;exec();7. $eTime = getMillisecond();8. var_dump($eTime - $sTime);</code></pre><h2 id="结果（多次）：-2"><a href="#结果（多次）：-2" class="headerlink" title="结果（多次）："></a>结果（多次）：</h2><ol><li>float(42)</li><li>float(44)</li><li>float(49)</li></ol><h1 id="初步结论"><a href="#初步结论" class="headerlink" title="初步结论"></a>初步结论</h1><ol><li>由测试结果可以看出，管道技术由于合并了多次请求，可以有效的减少执行时间，加快效率。</li><li>而一般型的事务可能只是把所有命令做了一个队列并依次发送，并没有合并请求。</li></ol><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ol><li>以上结果目前只适用于PHP语言的phpredis扩展。</li><li>不过可以推测在其他场景下使用管道应该也可以提升效率。待测试。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Redis </tag>
            
            <tag> 管道 </tag>
            
            <tag> 性能提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 生成器 可以做什么？</title>
      <link href="/2016/12/28/php-Generators/"/>
      <url>/2016/12/28/php-Generators/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生成器 “generators” 的概念是在 PHP 5.5.0 版本新提出的重要新特性之一。<br>这应该是一个很强大的工具，但似乎很多PHPer并不熟悉这个概念，更谈不上应用它。<br>所以我认为需要花点时间来解释一下它是如何工作的以及如何充分的利用他简化代码实现比较困难的功能。</p></blockquote><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p>首先我们来搞清楚一件事情——生成器到底是什么鬼？要说这么“牛X”的东东，会不会是解决某些问题的唯一办法 或者 是最简单的办法呢？非也！非也！她并不是你一见钟情的“唯一”(PS：实际上脱离任何一个依赖项，并不会引起世界大乱，总有其他替代品）。实际上，“生成器”并没有给PHP带来任何兼容性问题，任何她能干的事情，你都能通过“iterator”来实现，不要被这个新的概念“唬住”了。</p><h2 id="那么我们先来Look-一个例子："><a href="#那么我们先来Look-一个例子：" class="headerlink" title="那么我们先来Look 一个例子："></a>那么我们先来Look 一个例子：</h2><p>比如说我们来遍历一个文件的每一行(这也是RFC使用的一个例子，但是这里选择它还有特殊的原因，先卖关子)，“翠花”上代码先：</p><pre><code>$f = fopen($file, &#39;r&#39;);while ($line = fgets($f)){    doSomethingWithLine($line);}</code></pre><p>这是再普通不过的应用了，但是如果我们想把它抽象化调用的话会怎么样呢？比如说，我们想通过一些抽象的资源来读取这些数据的话该怎么办？可能我们今天从文件中获取数据，但是也许明天我们需要改为通过数据库获取数据记录，也或许从一个专有服务调用获取数据包，甚至其他可能的途径。</p><h2 id="到目前为止，我们有两种途径来实现。"><a href="#到目前为止，我们有两种途径来实现。" class="headerlink" title="到目前为止，我们有两种途径来实现。"></a>到目前为止，我们有两种途径来实现。</h2><ul><li>1、通过方法调用（Class::function()的方式）返回一个Array。</li><li>2、也可返回一个iterator迭代器。</li></ul><p>方法调用每次返回数组，这会有两个麻烦：</p><ul><li>第一、可能无法把所有数据load到内存中（小文件当然没问题，但是如果文件30G的话怎么办呢？）。</li><li>第二、我们可能根本无法构建这么一个数组（例如，构建一个“无限数列”，让客户端(方法调用者)判定队列中已经填充有多少元素）。</li></ul><p>所以留给我们的就只有使用iterator了，上面的代码可以很简洁的转换成一个iterator迭代器。事实上对于这个例子，PHP已经有内置的迭代器为我们实现了.<br>那就是“流X哄哄”的：SPLFileObject。处于做范例讲解的原因，我们自己来实现一下：</p><pre><code>class FileIterator implements Iterator {    protected $f;    public function __construct($file) {        $this-&gt;f = fopen($file, &#39;r&#39;);        if (!$this-&gt;f) throw new Exception();    }    public function current() {        return fgets($this-&gt;f);    }    public function key() {        return ftell($this-&gt;f);    }    public function next() {}    public function rewind() {        fseek($this-&gt;f, 0);    }    public function valid() {        return !feof($this-&gt;f);    }}</code></pre><p>觉的很简单是不是？事实上，不完全是。如果你仔细看这个代码，你会发现这个代码并不符合iterator的规则要求。<br>Next 和 Rewind方法是迭代器iterator支持的唯一触发方法，另外调用current多次应该返回同样的值。但是这里不是，基于某些原因这里我故意设下这个错误，来展示如何直接将代码转换为迭代器。<br>实际上要正确的实现没那么容易，那么让我们来看一下正确的实现是什么样子：</p><pre><code>class FileIterator implements Iterator {    protected $f;    protected $data;    protected $key;    public function __construct($file) {        $this-&gt;f = fopen($file, &#39;r&#39;);        if (!$this-&gt;f) throw new Exception();    }    public function __destruct() {        fclose($this-&gt;f);    }    public function current() {        return $this-&gt;data;    }    public function key() {        return $this-&gt;key;    }    public function next() {        $this-&gt;data = fgets($this-&gt;f);        $this-&gt;key++;    }    public function rewind() {        fseek($this-&gt;f, 0);        $this-&gt;data = fgets($this-&gt;f);        $this-&gt;key = 0;    }    public function valid() {        return false !== $this-&gt;data;    }}</code></pre><p>哇～，要实现一个简单的文件迭代任务需要这么多代码来维护各种状态(不过不要紧，大多数像这样繁重的工作都已经有内置函数实现了)。接下来，想象一下如果你需要操作更多的状态或者处理更复杂的算法实现，将会是什么样子？当然了，你可以通过各种方法调用来存储和操作状态，但那仍然是非常困难的，还有更麻烦的是各种调用组合。</p><h2 id="所以才引入了“generator”来解决这样的问题："><a href="#所以才引入了“generator”来解决这样的问题：" class="headerlink" title="所以才引入了“generator”来解决这样的问题："></a>所以才引入了“generator”来解决这样的问题：</h2><pre><code>function getLines($file) {    $f = fopen($file, &#39;r&#39;);    if (!$f) throw new Exception();    while ($line = fgets($f)) {        yield $line;    }    fclose($f);}</code></pre><p>看上去是不是简单多了？实际上是相同功能不同语法，只是用了新的关键词yield。</p><h1 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h1><p>这里要注意的重要一点是函数的返回值已经改变。 yield关键字的存在使PHP引擎返回特殊Generator类的实例。 该类实现了Iterator，因此可以直接在迭代上下文中使用：</p><pre><code>foreach (getLines(&quot;someFile&quot;) as $line) {    doSomethingWithLine($line);}</code></pre><p>最酷的是我们可以随机构建任何我们想要的代码，只需要 yield 每一步迭代的值即可。那么，具体怎么运行的呢？<br>我们来看一下，当你调用getLines()方法时，PHP会运行代码直到遇到第一个“yield”，这个时候会记住这个值并返回Generator的实例，<br>然后当next()被Generator对象内部调用的时候，PHP将会继续从上一个“yield”语句处重复运行，直到遇到下一个“yield” 或者 到达方法末尾的return 结束。</p><p>理解了这点之后，下面构建一个有用的生成器：</p><pre><code>function doStuff() {    $last = 0;    $current = 1;    yield 1;    while (true) {        $last = $current - $last;        $current = $last + $current;        yield $current;    }}</code></pre><p>你能看出他是做什么吗？乍一看，像一个死循环，对么？对喽，实际上如果我们想，它确实可以成为一个死循环。<br>但是仔细看看一下，你会发现它其实是用最简单的办法实现了一个“斐波那契数列”，那么我们就测试一下这个数列的计算与使用公式的计算进行比较，看他们的差距如何，上示例代码：<br>下面使用Generator构建的数列，可以测试内存使用和计算需要的时间</p><pre><code>&#x2F;&#x2F; Commond line params$var = $argv[1];&#x2F;&#x2F; Generator way ,since 5.5.0$memoryStart = memory_get_usage();$timeStart = microtime(true);function doStuff() {    $last = 0;    yield 0;    $current = 1;    yield 1;    while (true) {            $current = $last + $current;            $last = $current - $last;            yield $current;    }}&#x2F;&#x2F; Iterate the generator way,save memoryforeach(doStuff() as $key =&gt; $number){    if($key == $var)    {        echo $number;        break;    }}$memoryEnd = memory_get_usage();$timeEnd = microtime(true);echo &#39;-Memory Usage:&#39;,$memoryEnd-$memoryStart,&#39;-Runtime:&#39;,$timeEnd-$timeStart,PHP_EOL;</code></pre><p>再来看看直接使用数学公式，递归的方式进行计算(与循环的方式类似)的运行情况：</p><pre><code>&#x2F;&#x2F; Simple traditional way, huge memory usage.crash when number larger$memoryStart2 = memory_get_usage();$timeStart2 = microtime(true);function foo($i){    if($i == 0) return 0;    if($i == 1) return 1;    return foo($i-2)+foo($i-1);}$number = foo($var);$memoryEnd2 = memory_get_usage();$timeEnd2 = microtime(true);echo $number, &#39;-Memory Usage:&#39;,($memoryEnd2-$memoryStart2),&#39;-Runtime:&#39;,$timeEnd2-$timeStart2,PHP_EOL;echo &#39;Recursive call calculate consume Time is &#39;,($timeEnd2-$timeStart2) &#x2F; ($timeEnd-$timeStart),&#39; times of Generator iterator!!&#39;,PHP_EOL;</code></pre><p>可见在某些场景下，效果巨大差距非常明显，但是必须记住的是，Generator并非Iterator的替代，而只是一种简便或者更有效的实现方式。<br>Iterator 仍然有强大的用途，特别是在集合类中，需要维护一系列明确的对象状态的场景是极其有效地。</p><h2 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h2><p>比方说我们要创建一个用户空间的ArrayObject实现，不是实现迭代器，并且需要我们手动处理数组迭代，我们可以用点儿小技巧。<br>我们可以通过实现IteratorAggregate接口来构建我们自己的生成器，该接口要求一个单一方法：getIterator()。<br>因为生成器方法返回一个实现了Iterator的对象，所以我们可以通过实现接口的方法来构造我们自己的生成器！想象一下下面这个简单的类：<br><pre><code>class ArrayObject implements IteratorAggregate {    protected $array;    public function __construct(array $array) {        $this-&gt;array = $array;    }    public function getIterator() {        foreach ($this-&gt;array as $key =&gt; $value) {            yield $key =&gt; $value;        }    }}</code></pre></p><p>如此简单的实现，很容易掌握，并且如果你注意的话，我们可以使用通常的key语法，返回一个自定义的key。这里的重点是它带有一个复杂的任务(明确的存储状态)并且我们显式的完成它，用语言优势完成它。这样我们可以专注于完成业务，而避免去尝试一大堆的模板代码，但我们没有完成…</p><p>发送反馈数据<br>我们同样可以选择使用generator返回数据。yield方法也可以返回一个value值，即使用send()发给generator的值。这可能会比较方便，取决于我们想要做什么。所以，我们来看一个例子。比如说，我们要记录一堆日志数据。当然了，我们可以写一个功能齐全的重量级日志类，分别维护各种状态实现(我们一定可以很好地完成)，但是这里我们可以简单的使用一个生成器(Generator)完成：<br><pre><code>function createLog($file) {    $f = fopen($file, &#39;a&#39;);    while (true) {        $line = yield;        fwrite($f, $line);    }}$log = createLog($file);$log-&gt;send(&quot;First&quot;);$log-&gt;send(&quot;Second&quot;);$log-&gt;send(&quot;Third&quot;);</code></pre></p><p>及其简单…可能确实太简单的原因，那么我们看一个复杂一点儿的例子。一个协同程序(协同程序共同工作，来产生往复控制)。比如说，我们要构造一个队列批处理系统，可以提取数据，可以批量发送往返数据。就如同读取二进制流是反复读取指定长度的信息一样。我们可以手动将它们链接起来，或者我们创建一些列的生成器来实现：</p><h1 id="参考列表："><a href="#参考列表：" class="headerlink" title="参考列表："></a>参考列表：</h1><p>PHP官方文档：<a href="http://php.net/manual/zh/language.generators.overview.php" target="_blank" rel="noopener">http://php.net/manual/zh/language.generators.overview.php</a><br>Anthony Ferrara博客：<a href="http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html" target="_blank" rel="noopener">http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html</a><br>PHP 5.5: The Power to Yield: <a href="http://cogitolearning.co.uk/?p=821" target="_blank" rel="noopener">http://cogitolearning.co.uk/?p=821</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
