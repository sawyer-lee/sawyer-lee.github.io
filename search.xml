<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CGI，FastCGI以及PHP的实现</title>
      <link href="/2019/02/25/CGI-FastCGI-And-PHP/"/>
      <url>/2019/02/25/CGI-FastCGI-And-PHP/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是CGI："><a href="#什么是CGI：" class="headerlink" title="什么是CGI："></a>什么是CGI：</h1><p>&emsp;&emsp;通用网关接口，是WebServer和外部程序之间的通讯协议。早期的WebServer是只处理静态内容的，但是随着WWW的发展交互性要求越来越强，出现了各种动态处理语言实现复杂的功能。Web端的业务逻辑越来越复杂将这些都交给WebServer处理不现实，而且各种编程语言各自独立且有各自的知识产权，因此就出现了CGI协议，它使WebServers把复杂的逻辑交给各编程语言。</p><p>&emsp;&emsp;CGI的好处就是使WebServer完全独立于语言，仅仅是做为中间接口协议，链接WebServer和外部程序。他们通过cgi搭线来完成数据传递。这样做的好处是尽量减少2个的关联，使他们2变得更独立。CGI可以用任何编程语言编写，只要这种语言具有标准输入、输出和环境变量，例如：perl、PHP等。事实上第一个CGI实现就是用Perl[‘pə:l]写的。</p><h2 id="原理流程："><a href="#原理流程：" class="headerlink" title="原理流程："></a>原理流程：</h2><ul><li>1、客户端访问一个地址，通过HTTP协议发送请求（GET/POST/PUT/DELTE etc.）给WebServer。</li><li>2、WebServer会Fork一个子进程，将请求描述信息通过标准输入STDIN和环境变量传给CGI程序。</li><li>3、启动CGI外部程序处理请求，处理结果通过标准输出STDOUT返回给WebServer子进程，并结束和销毁相关资源。</li><li>4、有WebServer子进程通过HTTP协议将数据返回给客户端。</li><li>5、通常Web服务器使用*unix Shell环境变量来保存参数和环境变量。</li></ul><p><img src="/img/2018-02/cgi.jpg" alt="&quot;流程图如图示&quot;"></p><h2 id="CGI有个致命的弱点："><a href="#CGI有个致命的弱点：" class="headerlink" title="CGI有个致命的弱点："></a>CGI有个致命的弱点：</h2><p>每一个请求都会fork一个CGI进程处理，也就是最为人诟病的Fork-And-Execute模式，所以性能低下。</p><h1 id="什么是FastCGI"><a href="#什么是FastCGI" class="headerlink" title="什么是FastCGI:"></a>什么是FastCGI:</h1><p>&emsp;&emsp;FastCGI是Web服务器和处理程序之间通信的一种协议， 是CGI的一种改进方案，FastCGI像是一个常驻(long-lived)型的CGI， 它可以一直执行，在请求到达时不会花费时间去fork一个进程来处理(这是CGI最为人诟病的fork-and-execute模式)。 因为是通信协议可以通过Socket通讯，所以它还支持分布式的运算， FastCGI 程序可以在网站服务器以外的主机上执行，并且可以接受来自其它网站服务器的请求。FastCGI 是与语言无关的、可伸缩架构的 CGI 开放扩展，主要特点是将 CGI 解释器进程保持在内存中，不需要反复fork，以此获得较高的性能。 CGI 程序反复加载是CGI性能低下的主要原因，如果 CGI 程序保持在内存中并接受 FastCGI 进程管理器调度， 则可以提供良好的性能、伸缩性、Fail-Over 特性等。</p><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ul><li>1.WebServer启动时载入FastCGI进程管理器，IIS的ISAPI，Apache的Mod_PHP，Nginx借助PHP-FPM</li><li>2.FastCGI进程管理器自身初始化（解析PHP.ini以及环境变量等），启动多个子进程/CGI解析器，等待webServer的链接。</li><li>3.客户端请求到达Web Server时，FastCGI解释器选择并链接到一个子进程(PHP-FPM或PHP-CGI)，将标准输入和环境变量发送给子进程。</li><li>4.FastCGI子进程处理后将标准输出和错误信息从同一连接返回WebServer，当FastCGI子进程关闭连接时 请求处理便完成了。</li><li>5.CGI下这时进程退出了，但是FastCGI该子进程会继续运行并等待下一个连接请求。<br>  CGI中每一个请求，PHP都必须重新初始化PHP.ini，载入扩展或者dll并重初始化所有环境变量等。<br>  FastCGI只有在进程启动时做一次，之后便一直运行，这有另外一个好处就是可以使用外部数据的长连接模式。</li></ul><h1 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI:"></a>PHP-CGI:</h1><p>&emsp;&emsp;PHP-CGI是php官方出品的fastcgi管理器，不支持平滑重启，改了php.ini就要kill掉原来的php-cgi再重新启动才能生效；不支持动态worker调度，只能一开始指定要起几个worker。</p><h1 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM:"></a>PHP-FPM:</h1><p>&emsp;&emsp;FPM(FastCGI Process Manager)是PHP FastCGI运行模式的一个进程管理器，但是在早期他只是是PHP的一个扩展，PHP 5.3.3合并到主分支。加入了动态调度功能，可以根据请求来访压力变化动态增减worker进程数量；支持reload指令，让worker进程在完成当前请求后重启，并应用php.ini新配置。另外像Apache的mod_fcgid和IIS的PHP Manager需要调用php-cgi进程, 但php-fpm则根本不依赖php-cgi,完全独立运行,也不依赖php(cli)命令行解释器. 因为php-fpm是一个内置了php解释器的FastCGI服务,启动时能够自行读取php.ini配置和php-fpm.conf配置. </p><p>&emsp;&emsp;FPM的核心功能是进程管理，那么它用来管理什么进程呢？这个就需要从FastCGI说起了。FastCGI前面有详细的介绍了，注意：它只是一种协议！PHP是一个脚本解析器，你可以把它理解为一个普通的函数，输入是PHP脚本；输出是执行结果，相对于WebServer来说他就是一个外部程序处理动态请求。</p><p>&emsp;&emsp;在网络应用场景下，PHP需要接收请求、解析协议，然后处理完成返回请求，然而PHP并没有像Golang那样实现http网络库，而是实现了FastCGI协议，然后与web服务器配合实现http的处理。借助于web服务器来解析http请求，然后将解析的结果再通过FastCGI协议转发给PHP处理程序，PHP处理完成后将结果返回给web服务器，web服务器再返回给用户。</p><p><img src="/img/2018-02/fastcgi.png" alt="&quot;FastCGI流程图如图示&quot;"></p><p>通常程序处理模型有两种：多进程、多线程。</p><p>&emsp;&emsp;PHP本身不支持多线程，要实现多线程需要借助于其他第三方扩展来实现，对于PHP来说通常采用多进程模型。多进程模型通常是主进程只负责管理子进程，而基本事件由各个子进程处理，nginx、fpm就是这种模式；另一种多线程模型与多进程类似，只是它是线程粒度，通常会由主线程监听、接收请求，然后交由子线程处理，例如，Java，C++等都是支持多线程的。</p><p>&emsp;&emsp;概括来说，fpm就是创建一个master进程，在master进程中创建并监听socket，然后fork出多个子进程，这些子进程各自accept请求，子进程的处理非常简单，它在启动后阻塞在accept上，有请求到达后开始读取请求数据，读取完成后开始处理然后再返回，在这期间是不会接收其它请求的，也就是说fpm的子进程同时只能响应一个请求，只有把这个请求处理完成后才会accept下一个请求，这一点与nginx的事件驱动有很大的区别，nginx的子进程通过epoll管理套接字，如果一个请求数据还未发送完成则会处理下一个请求，即一个进程会同时连接多个请求，它是非阻塞的模型，只处理活跃的套接字。master进程不处理请求，只负责进程管理、异步事件和定时器事件处理。</p><p>fpm可以同时监听多个端口，每个端口对应一个worker pool，而每个pool下对应多个worker进程，类似nginx中server概念，一个pool对应一个nginx的站点，这样可以提高安全，如同站点切割。</p><p><img src="/img/2018-02/worker_pool.png" alt="&quot;PHP-FPM Worker Poll&quot;"></p><p>在php-fpm.conf中通过[pool name]声明一个worker pool：<br><pre><code>[web1]listen = 127.0.0.1:9000...[web2]listen = 127.0.0.1:9001...启动fpm后查看进程：ps -aux|grep fpmroot     27155  0.0  0.1 144704  2720 ?        Ss   15:16   0:00 php-fpm: master process (&#x2F;usr&#x2F;local&#x2F;php7&#x2F;etc&#x2F;php-fpm.conf)nobody   27156  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1nobody   27157  0.0  0.1 144676  2416 ?        S    15:16   0:00 php-fpm: pool web1nobody   27159  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2nobody   27160  0.0  0.1 144680  2376 ?        S    15:16   0:00 php-fpm: pool web2</code></pre></p><p>&emsp;&emsp;PHP-FPM的master进程与worker进程之间不会直接进行通信，master通过共享内存获取worker进程的信息，比如worker进程当前状态、已处理请求数等。当master进程要杀掉一个worker进程时则通过发送信号的方式通知worker进程。</p><p>&emsp;&emsp;每个worker进程都内置PHP解释器并且进程常驻后台，支持prefork动态增加，支持在运行时编译脚本，并在内存中缓存生成的opcode来提升性能。每个worker进程支持配置响应指定请求数后自动重启，master进程会重启挂掉的worker进程。</p><p>&emsp;&emsp;因为常驻内存特性worker进程能保持一个到MySQL/Memcached/Redis的持久连接实现”连接池”，避免重复建立连接对程序透明，但是注意：<strong><em> 使用数据库持久连接时应该设置固定数量的worker进程数,不要使用动态的prefork模式。且进程数不要超过资源的最大连接数，否则连接数用尽程序将不可用。</em></strong> PHP-FPM管理worker有三种模式：static，dynamic，ondemand：</p><ul><li>static模式下配置固定数量的worker；</li><li>dynamic模式下根据配置启动初始worker数量，按照运行情况动态prefork一组，直到最大数量max_children，如果此时所有worker繁忙master进程会把请求挂起到连接队列backlog里(默认值是511).。</li><li>ondemand模式下没有初始worker运行，当请求来了创建worker，处理请求完成后保持worker不退出，直到达到配置的超时时间被主进程关闭。</li></ul><p>参考：<br>FPM的架构：<a href="https://www.cnblogs.com/huanxiyun/articles/5413755.html" target="_blank" rel="noopener">https://www.cnblogs.com/huanxiyun/articles/5413755.html</a><br>PHP内核：<a href="https://github.com/pangudashu/php7-internal/blob/master/1/fpm.md" target="_blank" rel="noopener">https://github.com/pangudashu/php7-internal/blob/master/1/fpm.md</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> CGI </tag>
            
            <tag> FastCGI </tag>
            
            <tag> PHP-FPM </tag>
            
            <tag> PHP-CGI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP协议三次握手和四次挥手过程详解</title>
      <link href="/2018/03/12/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
      <url>/2018/03/12/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>TCP提供了一种可靠的面向连接的字节流运输层服务。TCP将用户数据打包成报文段，它发送后启动一个定时器，另一端收到的数据进行确认，对失序的数据重新排序，丢弃重复数据，TCP提供端到端的流量控制，并计算和验证一个强制性的端到端的检验和。许多流行的应用程序如：Telnet， Rlogin， FTP，SMTP 都使用TCP。</p><h4 id="TCP的主要特点："><a href="#TCP的主要特点：" class="headerlink" title="TCP的主要特点："></a>TCP的主要特点：</h4><ul><li>TCP是面向连接的运输层协议</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）。<ul><li>每一条 TCP 连接有两个端点 TCP 连接的端点不是主机,不是主机的IP 地址,不是应用进程,也不是传输层的协议端口.</li><li>TCP 连接的端点叫做套接字(socket)或插口。</li></ul></li><li>TCP提供可靠交付的服务</li><li>TCP提供全双工通信</li><li>面向字节流。<ul><li>面向字节流的含义：虽然应用程序和TCP交互是一次一个数据块，但TCP从应用程序交下来的数据仅仅是一连串的无结构的字节流</li><li>TCP将字节流进行封装添加TCP头部组成TCP报文段之后，在IP协议层进行传输。</li><li>TCP 对应用进程一次把多长的报文发送到TCP的缓存中是不关心的，TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节(UDP 发送的报文长度是应用进程给出的) TCP 可把太长的数据块划分短一些再传送.TCP 也可等待积累有足够多的字节后再构成报文段发送出去。</li></ul></li><li>TCP 传送的数据单位协议是 TCP 报文段(segment)</li></ul><h4 id="自动重传请求ARQ"><a href="#自动重传请求ARQ" class="headerlink" title="自动重传请求ARQ"></a>自动重传请求ARQ</h4><p>可靠传输协议常称为自动重传请求ARQ (Automatic Repeat reQuest)。</p><ul><li><p>累积确认机制:</p><ul><li>定义:　　接收方一般采用累积确认的方式.即不必对收到的分组逐个发送确认,而是对按序到达的最后一个分组发送确认,这样就表示：到这个分组为止的所有分组都已正确收到了</li><li>优点:　　容易实现,即使确认丢失也不必重传</li><li>缺点:　　不能向发送方反映出接收方已经正确收到的所有分组的信息</li></ul></li><li><p>Go-back-N(回退N):</p><ul><li>如果发送方发送了前 5 个分组,而中间的第 3 个分组丢失了.这时接收方只能对前两个分组发出确认.发送方无法知道后面三个分组的下落,而只好把后面的三个分组都再重传一次</li></ul></li></ul><h4 id="TCP面向流的概念和流程"><a href="#TCP面向流的概念和流程" class="headerlink" title="TCP面向流的概念和流程"></a>TCP面向流的概念和流程</h4><p>说明:</p><ul><li>TCP 连接的每一端都必须设有两个窗口      一个发送窗口和一个接收窗口</li><li>TCP 可靠传输机制用字节的序号进行控制.TCP 所有的确认都是基于序号而不是基于报文段</li><li>TCP 两端的四个窗口经常处于动态变化之中</li><li>TCP连接的往返时间 RTT 也不是固定不变的.需要使用特定的算法估算较为合理的重传时间</li></ul><p><img src="/img/2018-02/TCP-Data-Flow.png" alt="TCP字节流"></p><h4 id="TCP协议首部组成"><a href="#TCP协议首部组成" class="headerlink" title="TCP协议首部组成"></a>TCP协议首部组成</h4><p><img src="/img/2018-02/TCP-Header-4.jpg" alt="TCP头部结构"></p><p>各自段的含义如下：</p><ul><li><p>源端口和目的端口：各占两个字节，端口是运输层与应用层的服务接口，运输层的复用和分解功能都要通过端口才能实现。</p></li><li><p>32位序号：占4字节，序号范围是[0,2^32-1]。TCP把在一个TCP连接中传输的数据流中的每一个字节都编上一个序号。</p></li><li><p>32位确认号：是期望收到对方的下一个报文段的数据第一个字节的序号。</p><ul><li>若确认号 == N,则表明到序号N-1为止的所有数据都已正确收到。</li><li>例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；</li></ul></li><li><p>数据偏移：占4bit，他指出TCP报文的数据段距离起始位置有多远。</p></li><li><p>保留：6bit, 均为0.</p></li><li><p>紧急URG：当URG=1时，表示报文段中有紧急数据，应尽快传送，而不要按照原来的排队顺序传送，与“紧急指针”字段配合使用。</p></li><li><p>确认ACK：只有当ACK = 1时确认号才有效。</p></li><li><p>推送PSH：接收TCP收到PSH为1的报文段后，不再等到整个缓存都填满后在向上交付，而是尽快的交付给应用进程。</p><ul><li>当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；会立即创建一个报文段发送出去，</li></ul></li><li><p>复位RST：复位比特也称重建比特或重置比特。当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后在重新建立连接。</p></li><li><p>同步SYN：在建立连接是用来同步序号。SYN=1， ACK=0表示一个连接请求报文段。响应报文中SYN=1，ACK=1表示同意建立连接。</p></li><li><p>终止FIN：用来释放一个连接。FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放运输连接。</p></li><li><p>窗口：占2字节，用来控制对方发送的数据量。</p><ul><li>单位为字节，TCP连接的一端根据设置的缓存空间大小确定自己的接收窗口大小，然后通知发送方已确定的发送窗口上限，窗口的值是经常在动态变化，最大2^16-1个字节。</li></ul></li><li><p>检验和：占2字节，检验和字段检验的范围包括首部和数据这两部分。</p><ul><li>源机器基于数据内容计算一个数值，收信息机要与源机器数值结果完全一样，从而证明数据的有效性。</li><li>检验和覆盖了整个的TCP报文段：这是一个强制性的字段，一定是由发送端计算和存储，并由接收端进行验证的。</li><li>在计算检验和时,要在 TCP 报文段的前面加上 12 字节的伪首部。</li></ul></li><li><p>紧急指针：占2字节，紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。是一个正偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。</p></li><li><p>选项：长度可变，必须是4字节整数倍，不够的补0，最长可达40字节，因此 首部最大长度 60字节。</p><ul><li>TCP 最初只规定了一种选项,即最大报文段长度 MSS.</li><li>MSS 告诉对方TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节.” </li><li>MSS(Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度（默认536字节）. 数据字段加上 TCP 首部才等于整个的 TCP 报文段。</li></ul></li><li><p>填充: 这是为了使整个首部长度是 4 字节的整数倍。</p></li><li><p>其他选项:</p><ul><li>窗口扩大: 占 3 字节,其中有一个字节表示移位值 S.新的窗口值等于TCP 首部中的窗口位数增大到(16 + S),相当于把窗口值向左移动 S 位后获得实际的窗口大小。</li><li>时间戳:　 占10 字节,其中最主要的字段时间戳值字段(4字节)和时间戳回送回答字段(4字节)。</li><li>选择确认: 接收方收到了和前面的字节流不连续的两2字节.如果这些字节的序号都在接收窗口之内,那么接收方就先收下这些数据,但要把这些信息准确地告诉发送方,使发送方不要再重复发送这些已收到的数据</li></ul></li></ul><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><h4 id="三次握手的详述"><a href="#三次握手的详述" class="headerlink" title="三次握手的详述"></a>三次握手的详述</h4><p>&emsp;&emsp;首先Client端发送连接请求报文，Server段接受连接后回复ACK报文，并为这次连接分配资源。Client端接收到ACK报文后也向Server段发生ACK报文，并分配资源，这样TCP连接就建立了。</p><p><img src="/img/2018-02/tcp-handsnake.png" alt="&quot;TCP三次握手过程&quot;"></p><p>&emsp;&emsp;最初两端的TCP进程都处于CLOSED关闭状态，A主动打开连接，而B被动打开连接。（A、B关闭状态CLOSED ==&gt;B收听状态LISTEN ==&gt; A同步已发送状态SYN-SENT ==&gt; B同步收到状态SYN-RCVD ==&gt; A、B连接已建立状态ESTABLISHED）</p><p>&emsp;&emsp;TCP服务器B进程先创建传输控制块TCB，准备接受客户进程的连接请求。然后服务器进程就处于LISTEN（收听）状态，等待客户的连接请求。若有，则作出响应。</p><p><strong> 1. 第一次握手：</strong><br>A的TCP客户进程也是首先创建传输控制块TCB，然后向B发出连接请求报文段，（首部的同步位SYN=1，初始序号seq=x，此时SYN=1的报文段不能携带数据）但要消耗掉一个序号，此时TCP客户进程进入SYN-SENT（同步已发送）状态。</p><p><strong> 2. 第二次握手：</strong><br>B收到连接请求报文段后，如同意建立连接，则向A发送确认，在确认报文段中（SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y），测试TCP服务器进程进入SYN-RCVD（同步收到）状态；</p><p><strong> 3. 第三次握手：</strong><br>TCP客户进程收到B的确认后，要向B给出确认报文段（ACK=1，确认号ack=y+1，序号seq=x+1）（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。TCP连接已经建立，A进入ESTABLISHED（已建立连接）。 当B收到A的确认后，也进入ESTABLISHED状态。</p><h4 id="为什么A还要发送一次确认呢？可以二次握手吗？"><a href="#为什么A还要发送一次确认呢？可以二次握手吗？" class="headerlink" title="为什么A还要发送一次确认呢？可以二次握手吗？"></a>为什么A还要发送一次确认呢？可以二次握手吗？</h4><p>　　主要为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。如A发出连接请求，但因连接请求报文丢失而未收到确认，于是A再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A工发出了两个连接请求报文段，其中第一个丢失，第二个到达了B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达B，此时B误认为A又发出一次新的连接请求，于是就向A发出确认报文段，同意建立连接，不采用三次握手，只要B发出确认，就建立新的连接了，此时A不理睬B的确认且不发送数据，则B一致等待A发送数据，浪费资源。</p><h4 id="Server端易受到SYN攻击？"><a href="#Server端易受到SYN攻击？" class="headerlink" title="Server端易受到SYN攻击？"></a>Server端易受到SYN攻击？</h4><p>服务器端的资源分配是在二次握手时分配的，而客户端的资源是在完成三次握手时分配的，所以服务器容易受到SYN洪泛攻击，SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server则回复确认包，并等待Client确认，由于源地址不存在，因此Server需要不断重发直至超时，这些伪造的SYN包将长时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络拥塞甚至系统瘫痪。</p><p>防范SYN攻击措施：降低主机的等待时间，使主机尽快的释放未连接的占用，短时间受到某IP的重复SYN则丢弃后续请求。</p><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><h4 id="四次挥手的详述"><a href="#四次挥手的详述" class="headerlink" title="四次挥手的详述"></a>四次挥手的详述</h4><p>　　假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p><p><img src="/img/2018-02/tcp-hand-wave.png" alt="TCP四次挥手过程&quot;"><br> 数据传输结束后，通信的双方都可释放连接，A和B都处于ESTABLISHED状态。（A、B连接建立状态ESTABLISHED——A终止等待1状态FIN-WAIT-1——B关闭等待状态CLOSE-WAIT——A终止等待2状态FIN-WAIT-2——B最后确认状态LAST-ACK——A时间等待状态TIME-WAIT——B、A关闭状态CLOSED）</p><p>1）A的应用进程先向其TCP发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。<br>2）B收到连接释放报文段后即发出确认报文段，（ACK=1，确认号ack=u+1，序号seq=v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。<br>3）A收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。<br>4）B没有要向A发出的数据，B发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），B进入LAST-ACK（最后确认）状态，等待A的确认。<br>5）A收到B的连接释放报文段后，对此发出确认报文段（ACK=1，seq=u+1，ack=w+1），A进入TIME-WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，A才进入CLOSED状态。</p><h4 id="为什么A在TIME-WAIT状态必须等待2MSL的时间？"><a href="#为什么A在TIME-WAIT状态必须等待2MSL的时间？" class="headerlink" title="为什么A在TIME-WAIT状态必须等待2MSL的时间？"></a>为什么A在TIME-WAIT状态必须等待2MSL的时间？</h4><p>MSL最长报文段寿命Maximum Segment Lifetime，MSL=2</p><p>两个理由：<br>1）TCP是全双工的，要保证链接能可靠关闭，所以必须保证A发送的最后一个ACK报文段能够到达B。<br>因为IP协议的不可靠性和其他原因，A段最后这个ACK报文段有可能丢失，使得处于LAST-ACK状态的B收不到对FIN+ACK报文段的确认，B超时重传FIN+ACK报文段，而A能在2MSL时间内收到这个重传的FIN+ACK报文段，接着A重传一次确认，重新启动2MSL计时器，最后A和B都进入到CLOSED状态，若A在TIME-WAIT状态不等待一段时间，而是发送完ACK报文段后立即释放连接，则无法收到B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则B无法正常进入到CLOSED状态。</p><p>2）防止本次链接中“已失效的请求报文段（错误、重复、异常等）”在连接通道中消失，避免影响其他链接。<br>如果Client直接CLOSED，然后又再向Server发起一个新连接，前面链接的某些无效数据依然滞留网络，这些延迟数据在建立新连接之后才到达Server，如果新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。</p><h4 id="为什么连接的时候是三次握手，关闭的时候却是四次握手？"><a href="#为什么连接的时候是三次握手，关闭的时候却是四次握手？" class="headerlink" title="为什么连接的时候是三次握手，关闭的时候却是四次握手？"></a>为什么连接的时候是三次握手，关闭的时候却是四次握手？</h4><p>因为当Server端收到Client端的SYN连接请求报文后，可以直接一并发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四步握手。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
            <tag> 三次握手 </tag>
            
            <tag> 四次挥手 </tag>
            
            <tag> TCP/IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名函数和闭包</title>
      <link href="/2018/03/12/class-closure-phpclosure/"/>
      <url>/2018/03/12/class-closure-phpclosure/</url>
      
        <content type="html"><![CDATA[<h1 id="何为匿名函数，闭包又是什么？"><a href="#何为匿名函数，闭包又是什么？" class="headerlink" title="何为匿名函数，闭包又是什么？"></a>何为匿名函数，闭包又是什么？</h1><ol><li><p>匿名函数（Anonymous functions），顾名思义，就是没有名称的函数，也叫闭包函数（closures），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（callback）参数的值。当然，也有其它应用的情况。</p></li><li><p>闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p></li><li><p>在PHP中匿名函数本质上是通过 <a href="http://php.net/manual/zh/class.closure.php" target="_blank" rel="noopener">Closure</a> 类来实现的。</p></li><li><p>匿名函数和闭包是在PHP 5.3 开始引入的新特性；PHP 5.4起 闭包内可以使用$this关键字；PHP 7.1 开始use不能使用superglobals、 $this，use的变量名不能和参数重名。</p></li></ol><h1 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h1><p>匿名函数示例，实际上闭包函数也可以作为变量的值来使用，把一个 closure对象（闭包函数本质上是closure类的对象）赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号“：”。。</p><pre><code>&lt;?php$greet = function($name){    printf(&quot;Hello %s\r\n&quot;, $name);};$greet(&#39;World&#39;);$greet(&#39;PHP&#39;);&#x2F;&#x2F;输出 Hello World 和 Hello PHP.?&gt;</code></pre><p>值为闭包调的变量用可以直接$greet()调用，因为本质上在赋值时PHP会自动把此种表达式转换成内置类 Closure 的对象实例。<strong><em> 可能有人说这是因为Closure实现了<strong>invoke()魔术方法，但是实际上闭包类实现</strong>invoke()魔术方法只是为了与其他实现了__invoke()魔术方法的对象保持一致性，但调用匿名函数的过程与它无关。</em></strong></p><p>Closure类的定义如下：<br><pre><code>Closure {&#x2F;* 方法 *&#x2F;__construct ( void )__invoke(void)public static bind ( Closure $closure , object $newthis [, mixed $newscope = &#39;static&#39; ] ) : Closurepublic bindTo ( object $newthis [, mixed $newscope = &#39;static&#39; ] ) : Closure}</code></pre></p><h1 id="闭包中变量的作用域"><a href="#闭包中变量的作用域" class="headerlink" title="闭包中变量的作用域"></a>闭包中变量的作用域</h1><p>闭包可以从父作用域中继承变量， 任何此类变量都应该用 use 语言结构传递进去。<br><pre><code>&lt;?php$message = &#39;hello&#39;;&#x2F;&#x2F; 没有 &quot;use&quot;$example = function () {    var_dump($message);};echo $example();&#x2F;&#x2F; 继承 $message$example = function () use ($message) {    var_dump($message);};echo $example();&#x2F;&#x2F; 注意：继承的变量值是在闭包函数定义时发生的，而不是调用时，所以这里不会输出 world$message = &#39;world&#39;;echo $example();</code></pre></p><p>执行上面这段代码会输出：</p><p>Notice: Undefined variable: message in /example.php on line 6<br>NULL<br>string(5) “hello”<br>string(5) “hello”<br>string(5) “hello”</p><p>报错因为php闭包不会像javascript闭包那样自动封装应用的状态，在php中，使用use关键字，把状态附加到php闭包上。需要注意最后一次输出是“hello”而不是“world”，因为闭包变量的继承是发生在闭包函数定义的时候，而不是在调用的时候才确定，因此$message = ‘world’，不会覆盖message的值。<strong><em>换句话说它可以保存当前上下文的各种状态数据，即使上下文环境已经消失，也正是因为这一特性，我们可以依赖它做一些有趣的事情。</em></strong></p><h1 id="接下来我们看一下闭包类的两个方法：bind-和bindTo"><a href="#接下来我们看一下闭包类的两个方法：bind-和bindTo" class="headerlink" title="接下来我们看一下闭包类的两个方法：bind()和bindTo()"></a>接下来我们看一下闭包类的两个方法：bind()和bindTo()</h1><h2 id="Closure-bind-方法"><a href="#Closure-bind-方法" class="headerlink" title="Closure::bind 方法"></a>Closure::bind 方法</h2><p>public static Closure::bind ( Closure $closure , object $newthis [, mixed $newscope = ‘static’ ] ) : Closure<br>复制一个闭包，绑定指定的$this对象和类作用域。这个方法是 Closure::bindTo() 的静态版本。</p><ul><li><p>closure<br>需要绑定的匿名函数。</p></li><li><p>newthis<br>需要绑定到匿名函数的对象，或者 NULL 创建未绑定的闭包。</p></li><li><p>newscope<br>想要绑定给闭包的类作用域，或者 ‘static’ 表示不改变。如果传入一个对象，则使用这个对象的类型名。 类作用域用来决定在闭包中 $this 对象的 私有、保护方法 的可见性。</p></li></ul><h2 id="Closure-bindTo方法"><a href="#Closure-bindTo方法" class="headerlink" title="Closure::bindTo方法"></a>Closure::bindTo方法</h2><p>public Closure::bindTo ( object $newthis [, mixed $newscope = ‘static’ ] ) : Closure<br>复制当前闭包对象，绑定指定的$this对象和类作用域。</p><p>创建并返回一个 匿名函数， 它与当前对象的函数体相同、绑定了同样变量，但可以绑定不同的对象，也可以绑定新的类作用域。</p><p>“绑定的对象”决定了函数体中的 $this 的取值，“类作用域”代表一个类型、决定在这个匿名函数中能够调用哪些 私有 和 保护 的方法。 也就是说，此时 $this 可以调用的方法，与 newscope 类的成员函数是相同的。</p><p>静态闭包不能有绑定的对象（ newthis 参数的值应该设为 NULL）不过仍然可以用 bubdTo 方法来改变它们的类作用域。</p><p>Note: <strong><em> 如果你只是想要复制一个匿名函数，可以用 cloning 代替。</em></strong></p><p>bindTo() 方法为闭包增加了一些有趣的潜力，我们可以使用这个方法把Closure对象绑定到其他的对象上，bindTo() 方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的php类，因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。</p><pre><code>&lt;?phptrait DynamicDefinition {        public function __call($name, $args) {        if (is_callable($this-&gt;$name)) {            return call_user_func($this-&gt;$name, $args);        }        else {            throw new \RuntimeException(&quot;Method {$name} does not exist&quot;);        }    }        public function __set($name, $value) {        $this-&gt;$name = is_callable($value)?             $value-&gt;bindTo($this, $this):             $value;    }}class Foo {    use DynamicDefinition;    private $privateValue = &#39;I am private&#39;;}$foo = new Foo;$foo-&gt;bar = function() {    return $this-&gt;privateValue;};&#x2F;&#x2F; prints &#39;I am private&#39;print $foo-&gt;bar();</code></pre><p>你会发现，php框架经常使用bindTo()方法把路由URL映射到匿名回调函数上，框架会把匿名函数绑定到应用对象上，这么做可以在这个匿名函数中使用 $this关键字引用重要的对象。</p><p>例如Laravel中的路由绑定，容器绑定等等，很多应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 闭包 </tag>
            
            <tag> closure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top和strace 查看某些或者某个进程</title>
      <link href="/2017/12/28/Top-commond-and-trace/"/>
      <url>/2017/12/28/Top-commond-and-trace/</url>
      
        <content type="html"><![CDATA[<p>Top 查看某些或者某个进程（top -p pid）</p><p>top中使用CPU或MEM排序，还是看不到我们想了解的进程的相关信息；这时就可以指定对某个或某些进程进行TOP信息显示；</p><p>1、查看某个进程的信息<br>例：mysqld的信息<br>(1)得到mysqld进程的pid<br>[root@6 ~]# pidof mysqld<br>21538</p><p>(2)top指定查看PID<br>[root@6 ~]# top -p 21538</p><p>top - 09:15:06 up 30 days, 53 min,  3 users,  load average: 0.07, 0.22, 0.23<br>Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie<br>Cpu(s):  3.0%us,  6.9%sy,  0.2%ni, 89.4%id,  0.3%wa,  0.1%hi,  0.1%si,  0.0%st<br>Mem:   1035140k total,   994888k used,    40252k free,   383072k buffers<br>Swap:  2048248k total,       80k used,  2048168k free,   237456k cached</p><p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>21538 mysql     15   0  146m  21m 4372 S  0.0  2.1   3:03.84 mysqld</p><p>2、查看某些进程的信息<br>例：mysqld/httpd的信息<br>(1)得到mysqld/httpd进程的pid<br>[root@6 ~]# pidof mysqld<br>21538</p><p>[root@6 ~]# pidof httpd<br>31117 31116 31115 31114</p><p>(2)top指定查看PID<br>[root@6 ~]# top -p 21538,31117,31116,31115,31114</p><p>top - 09:20:05 up 30 days, 58 min,  3 users,  load average: 0.37, 0.24, 0.23<br>Tasks:   5 total,   0 running,   5 sleeping,   0 stopped,   0 zombie<br>Cpu(s):  3.0%us,  6.9%sy,  0.2%ni, 89.4%id,  0.3%wa,  0.1%hi,  0.1%si,  0.0%st<br>Mem:   1035140k total,   994364k used,    40776k free,   383404k buffers<br>Swap:  2048248k total,       80k used,  2048168k free,   237560k cached</p><p>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND<br>21538 mysql     15   0  146m  21m 4372 S  0.0  2.1   3:03.86 mysqld<br>31117 apache    15   0 60036 8428 4668 S  0.0  0.8   0:00.48 httpd<br>31116 apache    15   0 60308 9.9m 6288 S  0.0  1.0   0:00.48 httpd<br>31115 apache    15   0 60100 8552 4756 S  0.0  0.8   0:00.48 httpd<br>31114 apache    15   0 59892 6452 3060 S  0.0  0.6   0:00.41 httpd </p><p>linux下用来跟踪某个进程的系统调用。<br>sudo strace -p 21538</p><ul><li>在solaris下，对应的是dtrace。</li><li>在mac下，对应的命令是：dtruss。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> linux </tag>
            
            <tag> Top </tag>
            
            <tag> strace </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用自增主键无数遍，但你真懂InnoDB自增吗？</title>
      <link href="/2017/12/28/mysql-auto-increment/"/>
      <url>/2017/12/28/mysql-auto-increment/</url>
      
        <content type="html"><![CDATA[<p>在一次宕机之后重启Mysql服务器并恢复数据的过程中发现了自增主键列的自增数值会回退，导致有数据上有冲突。<br>经过一番的排查之后发现了一个非常容易被忽略的事实，Mysql中自增ID的值在一定条件下会回退！因此导致自增主键有重复导，外键关联失效引起。</p><p>我们来举个例子说明一下具体的现象：<br>例如，创建一个个InNoDB引擎表:<br><pre><code>CREATE TABLE `bsession`  (    `id` int(10) unsigned NOT NULL AUTO_INCREMENT,    `aname` varchar(80) NOT NULL DEFAULT ‘’,    PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8;</code></pre></p><p>创建数据表之后，我们来插入一些数据来重现一下效果，插入 10条数据，<br><pre><code>INSERT INTO `bsession` (aname) values (&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a&#39;),(&#39;a’);</code></pre></p><p>接下来，再删除最后的几条数据，看看id的变化是怎样的，<br><pre><code>DELETE FROM bsession where id in (8,9,10);</code></pre></p><p><img src="/img/2017-12-28/mysql_innodb_auto_increment1.jpg" alt="&quot;更新数据后数据变化情况&quot;"></p><p>在删除部分数据之后表中的仅有7条，且最大的’id’ = 7, 现在进行数据库重启，并重新插入10条数据，我们验证一下自增列从8还是11开始自增计数，<br>看下图的数据变化，注意：id列的增长情况</p><p><img src="/img/2017-12-28/mysql_innodb_auto_increment2.jpg" alt="&quot;更新数据后数据变化情况&quot;"></p><p> 结果事实证明，自增列 id 的值出现了回滚，不是从11开始计数生成新纪录，而是继续了表中最大id，从8开始计数。<br> 说到这里肯定有人要问了是什么原因导致 自增属性字段，在重启后会回退呢？<br> 根据现象猜测大致原因如下：<br> <em>InNoDB的存储引擎是将AUTO_INCREMENT计数器的累计值存放到主内存中的; </em>大概是为了计数器的频繁跟新，为了保证速速并非存入硬盘文件，<br> *因为内存存储，当重启后内存数据就丢失了，启动后计数器的值只好从表中MAX(自增字段)来获取当前最大计数器值</p><p>要了解真实的原因以及进一步确认MySql的InnoDB引擎是如何处理自增列的，翻看查看官方文档找到了如下内容：<br><blockquote><p><img src="/img/2017-12-28/mysql_innodb_auto_increment3.jpg" alt="&quot;更新数据后数据变化情况&quot;"></p><footer><strong>AUTO_INCREMENT Handling in InnoDB</strong><cite><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-auto-increment-handling.html" target="_blank" rel="noopener">MySQL 5.7 Reference Manual</a></cite></footer></blockquote></p><p>查阅了不同版本的官方手册确认了截止Mysql 5.7 所有版本都存在这个问题，不过这个特性将在Mysql的下一个版本8.0中更改。<br>自增计数器每次更改时，当前的最大自增计数器值将会被写入redo log中，并保存到InnoDB引擎的私有系统表中，记录到每个检查点， 实现自增计数器的持久化，重启后值会保持一致。</p><p>当服器在Crash中恢复后，重启过程中InnoDB使用存储在系统字典表里的当前最大自增，并且从最后一个检查点开始扫描RedoLog中的计数器值。如果Redo Log中的值大于内存中的计数器值，Redo Log中的值将会被采用。</p><p>关于后续版本中对于 自增列的处理机制的更详细说明，请查看官方文档，这里不在赘述。<br><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-auto-increment-handling.html" title="[external] [MySQL 8.0 Reference Manual]" target="_blank" rel="noopener">InnoDB AUTO_INCREMENT Lock Modes</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
            <tag> auto_increment </tag>
            
            <tag> 自增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IT从业人的职业规划</title>
      <link href="/2017/12/28/IT%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/"/>
      <url>/2017/12/28/IT%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当你对某种技能已经有了一定的了解，开始觉得自己如同“行尸走肉”，成为一个开发工具的时候，那就应该要明确一下自己的发展方向了。</p><footer><strong>某位技术大牛</strong><cite>Sawyer.Lee</cite></footer></blockquote><h1 id="从大的方向来说基本三个大方向"><a href="#从大的方向来说基本三个大方向" class="headerlink" title="从大的方向来说基本三个大方向"></a>从大的方向来说基本三个大方向</h1><h2 id="单方面技术发展方向："><a href="#单方面技术发展方向：" class="headerlink" title="单方面技术发展方向："></a>单方面技术发展方向：</h2><ul><li><p>技术大牛方向：<br>1、精通PHP,Python,Java等语言特性，正确的使用各种语法、各种函数，编码规范、已读。<br>2、灵活运用各种数据类型，深入了解和应用语言数据结构、DB、NO-SQL。<br>3、正确合理的实现控制逻辑、更好地算法实现。</p></li><li><p>架构师方向:<br>1、真正去理解OOD、OOP思想并在实际开发工作中充分应用OO的设计、编码方法；<br>2、提高代码封装度(隔离保护，安全、降低复杂度，高复用好维护)、多态性(更好的维护性，更通用)、继承（更高的复用性扩展性）、<br>3、功能模块化、组件化、自动化、工具配置化。<br>4、很好的数据处理、高并发设计、大压力系统设计和优化。</p></li><li><p>技术专家方向：<br>1、设计优化框架，公共库组件、模块；成熟的业务模型解决方案。<br>2、吃透核心原理、WebServer运行原理、WebServer与PHP的通信原理等深入机制理解透彻，各种深度扩展，最大化发挥效率。<br>3、熟悉C并灵活运用可以写PHP扩展，定制化扩展和组件。</p></li></ul><h2 id="从技术向业务方向过渡。"><a href="#从技术向业务方向过渡。" class="headerlink" title="从技术向业务方向过渡。"></a>从技术向业务方向过渡。</h2><ul><li><p>第一个层级：<br>1、扎实的技术基础知识（HTML、CSS、JS、PS切图、UI、程序逻辑、数据库、程序体系结构）。<br>2、了解各种业务模型、各种行业业务流程，大致的开发流程、关键技术点、工作量（电商、游戏、金融、支付、App）。<br>3、最重要的沟通能力、业务理解能力、可以做好产品需求与开发人员的桥梁，熟悉项目管理。</p></li><li><p>第二层级：<br>1、较丰富的开发经验、了解各种开发语言以及特性、大用户高并发大数据系统经验，系统集成经验。<br>2、精通各种业务模型、数据统计方式、统计数据意义和价值、工作量的把握，业务拆分质量、验收、评估监督等。<br>3、很好的项目管理能力，理解能力极强，可沟通协调解决各种资源冲突、成本管理、风险管理等等，了解项目组人员性格量材分配。</p></li><li><p>第三个层级：<br>1、丰富的开发经验、熟悉各种开发语言以及特性、大用户高并发大数据系统经验，系统集成经验，熟悉各种解决方案。<br>2、业务把控能力、需求把关审核、深入了解各种业务模块、了解行业特性、竞争者情况并作出相应的决策。<br>3、管理多个项目组，hold住各种任务、各种部门和团队沟通协调、高级项目管理能力，PMP, 3Sigma, 6Sigma, CPM, TOGAF 等等。</p></li><li><p>第四个层级：<br>AVP/VP/FVP/GM….CEO…</p></li></ul><h2 id="从程序员向技术管理方向过渡。"><a href="#从程序员向技术管理方向过渡。" class="headerlink" title="从程序员向技术管理方向过渡。"></a>从程序员向技术管理方向过渡。</h2><ul><li>技术TL、很好的技术能力、能带新人、可以解决小组各种问题、性能优化、系统整合，核心业务开发。</li><li>技术TM/EM，团队管理、技术方案、很好的技术能力、丰富开发经验、大系统经验、架构、框架等等….</li><li>技术TD/ED，部门管理、研发团队管理、基层技术方案设计、技术方向把关、新技术研究应用、技术方案决策。</li><li>CTO/CIO…</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> IT行业 </tag>
            
            <tag> 职业规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Redis管道提升批量操作性能</title>
      <link href="/2017/02/20/Redis%E7%AE%A1%E9%81%93%E6%8F%90%E5%8D%87%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD/"/>
      <url>/2017/02/20/Redis%E7%AE%A1%E9%81%93%E6%8F%90%E5%8D%87%E6%93%8D%E4%BD%9C%E6%80%A7%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ol><li>最近在工作中使用了Redis的管道技术。</li><li>发现对于互不相关的多次Redis操作使用管道可以极大的提升性能。</li><li>特此记录。</li></ol><h1 id="浅析"><a href="#浅析" class="headerlink" title="浅析"></a>浅析</h1><ol><li>个人觉得问题可能出在TCP连接上。</li><li>Redis使用TCP协议进行数据传输，在多次Redis命令中会有大量的时间消耗在TCP握手上。</li><li>而管道可以合并多次TCP请求，统一发送，这样就可以节省大量的时间。</li></ol><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="初始化Redis连接"><a href="#初始化Redis连接" class="headerlink" title="初始化Redis连接"></a>初始化Redis连接</h2><ol><li>使用phpredis扩展，初始化Redis连接。</li><li>代码略。</li></ol><h2 id="获取毫秒数时间"><a href="#获取毫秒数时间" class="headerlink" title="获取毫秒数时间"></a>获取毫秒数时间</h2><pre><code>1. function getMillisecond() { 2.     list($s1, $s2) = explode(&#39; &#39;, microtime()); 3.     return (float)sprintf(&#39;%.0f&#39;, (floatval($s1) + floatval($s2)) * 1000); 4. } </code></pre><h2 id="不使用事务-代码段："><a href="#不使用事务-代码段：" class="headerlink" title="不使用事务 代码段："></a>不使用事务 代码段：</h2><pre><code>1. $sTime = getMillisecond();2. for ($i = 0; $i &lt; 10000; $i++) {3.     $this-&gt;redis-&gt;set(&#39;Test:test&#39; . $i,&#39;test&#39;);4. }5. $eTime = getMillisecond();6. var_dump($eTime - $sTime);</code></pre><h2 id="结果（多次）："><a href="#结果（多次）：" class="headerlink" title="结果（多次）："></a>结果（多次）：</h2><ol><li>float(3199)</li><li>float(3145)</li><li>float(3436)</li></ol><h2 id="使用参数为MULTI的一般事务-代码段："><a href="#使用参数为MULTI的一般事务-代码段：" class="headerlink" title="使用参数为MULTI的一般事务 代码段："></a>使用参数为MULTI的一般事务 代码段：</h2><pre><code>1. $sTime = getMillisecond();2. $this-&gt;redis-&gt;multi(Redis::MULTI);3. for ($i = 0; $i &lt; 10000; $i++) {4.     $this-&gt;redis-&gt;set(&#39;Test:test&#39; . $i,&#39;test&#39;);5. }6. $this-&gt;redis-&gt;exec();7. $eTime = getMillisecond();8. var_dump($eTime - $sTime);</code></pre><h2 id="结果（多次）：-1"><a href="#结果（多次）：-1" class="headerlink" title="结果（多次）："></a>结果（多次）：</h2><ol><li>float(3160)</li><li>float(3410)</li><li>float(3093)</li></ol><h2 id="使用参数为PIPELINE的管道事务-代码段："><a href="#使用参数为PIPELINE的管道事务-代码段：" class="headerlink" title="使用参数为PIPELINE的管道事务 代码段："></a>使用参数为PIPELINE的管道事务 代码段：</h2><pre><code>1. $sTime = getMillisecond();2. $this-&gt;redis-&gt;multi(Redis::PIPELINE);3. for ($i = 0; $i &lt; 10000; $i++) {4.     $this-&gt;redis-&gt;set(&#39;Test:test&#39; . $i,&#39;test&#39;);5. }6. $this-&gt;redis-&gt;exec();7. $eTime = getMillisecond();8. var_dump($eTime - $sTime);</code></pre><h2 id="结果（多次）：-2"><a href="#结果（多次）：-2" class="headerlink" title="结果（多次）："></a>结果（多次）：</h2><ol><li>float(42)</li><li>float(44)</li><li>float(49)</li></ol><h1 id="初步结论"><a href="#初步结论" class="headerlink" title="初步结论"></a>初步结论</h1><ol><li>由测试结果可以看出，管道技术由于合并了多次请求，可以有效的减少执行时间，加快效率。</li><li>而一般型的事务可能只是把所有命令做了一个队列并依次发送，并没有合并请求。</li></ol><h1 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h1><ol><li>以上结果目前只适用于PHP语言的phpredis扩展。</li><li>不过可以推测在其他场景下使用管道应该也可以提升效率。待测试。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> Redis </tag>
            
            <tag> 管道 </tag>
            
            <tag> 性能提升 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP 生成器 可以做什么？</title>
      <link href="/2016/12/28/php-Generators/"/>
      <url>/2016/12/28/php-Generators/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生成器 “generators” 的概念是在 PHP 5.5.0 版本新提出的重要新特性之一。<br>这应该是一个很强大的工具，但似乎很多PHPer并不熟悉这个概念，更谈不上应用它。<br>所以我认为需要花点时间来解释一下它是如何工作的以及如何充分的利用他简化代码实现比较困难的功能。</p></blockquote><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><p>首先我们来搞清楚一件事情——生成器到底是什么鬼？要说这么“牛X”的东东，会不会是解决某些问题的唯一办法 或者 是最简单的办法呢？非也！非也！她并不是你一见钟情的“唯一”(PS：实际上脱离任何一个依赖项，并不会引起世界大乱，总有其他替代品）。实际上，“生成器”并没有给PHP带来任何兼容性问题，任何她能干的事情，你都能通过“iterator”来实现，不要被这个新的概念“唬住”了。</p><h2 id="那么我们先来Look-一个例子："><a href="#那么我们先来Look-一个例子：" class="headerlink" title="那么我们先来Look 一个例子："></a>那么我们先来Look 一个例子：</h2><p>比如说我们来遍历一个文件的每一行(这也是RFC使用的一个例子，但是这里选择它还有特殊的原因，先卖关子)，“翠花”上代码先：</p><pre><code>$f = fopen($file, &#39;r&#39;);while ($line = fgets($f)){    doSomethingWithLine($line);}</code></pre><p>这是再普通不过的应用了，但是如果我们想把它抽象化调用的话会怎么样呢？比如说，我们想通过一些抽象的资源来读取这些数据的话该怎么办？可能我们今天从文件中获取数据，但是也许明天我们需要改为通过数据库获取数据记录，也或许从一个专有服务调用获取数据包，甚至其他可能的途径。</p><h2 id="到目前为止，我们有两种途径来实现。"><a href="#到目前为止，我们有两种途径来实现。" class="headerlink" title="到目前为止，我们有两种途径来实现。"></a>到目前为止，我们有两种途径来实现。</h2><ul><li>1、通过方法调用（Class::function()的方式）返回一个Array。</li><li>2、也可返回一个iterator迭代器。</li></ul><p>方法调用每次返回数组，这会有两个麻烦：</p><ul><li>第一、可能无法把所有数据load到内存中（小文件当然没问题，但是如果文件30G的话怎么办呢？）。</li><li>第二、我们可能根本无法构建这么一个数组（例如，构建一个“无限数列”，让客户端(方法调用者)判定队列中已经填充有多少元素）。</li></ul><p>所以留给我们的就只有使用iterator了，上面的代码可以很简洁的转换成一个iterator迭代器。事实上对于这个例子，PHP已经有内置的迭代器为我们实现了.<br>那就是“流X哄哄”的：SPLFileObject。处于做范例讲解的原因，我们自己来实现一下：</p><pre><code>class FileIterator implements Iterator {    protected $f;    public function __construct($file) {        $this-&gt;f = fopen($file, &#39;r&#39;);        if (!$this-&gt;f) throw new Exception();    }    public function current() {        return fgets($this-&gt;f);    }    public function key() {        return ftell($this-&gt;f);    }    public function next() {}    public function rewind() {        fseek($this-&gt;f, 0);    }    public function valid() {        return !feof($this-&gt;f);    }}</code></pre><p>觉的很简单是不是？事实上，不完全是。如果你仔细看这个代码，你会发现这个代码并不符合iterator的规则要求。<br>Next 和 Rewind方法是迭代器iterator支持的唯一触发方法，另外调用current多次应该返回同样的值。但是这里不是，基于某些原因这里我故意设下这个错误，来展示如何直接将代码转换为迭代器。<br>实际上要正确的实现没那么容易，那么让我们来看一下正确的实现是什么样子：</p><pre><code>class FileIterator implements Iterator {    protected $f;    protected $data;    protected $key;    public function __construct($file) {        $this-&gt;f = fopen($file, &#39;r&#39;);        if (!$this-&gt;f) throw new Exception();    }    public function __destruct() {        fclose($this-&gt;f);    }    public function current() {        return $this-&gt;data;    }    public function key() {        return $this-&gt;key;    }    public function next() {        $this-&gt;data = fgets($this-&gt;f);        $this-&gt;key++;    }    public function rewind() {        fseek($this-&gt;f, 0);        $this-&gt;data = fgets($this-&gt;f);        $this-&gt;key = 0;    }    public function valid() {        return false !== $this-&gt;data;    }}</code></pre><p>哇～，要实现一个简单的文件迭代任务需要这么多代码来维护各种状态(不过不要紧，大多数像这样繁重的工作都已经有内置函数实现了)。接下来，想象一下如果你需要操作更多的状态或者处理更复杂的算法实现，将会是什么样子？当然了，你可以通过各种方法调用来存储和操作状态，但那仍然是非常困难的，还有更麻烦的是各种调用组合。</p><h2 id="所以才引入了“generator”来解决这样的问题："><a href="#所以才引入了“generator”来解决这样的问题：" class="headerlink" title="所以才引入了“generator”来解决这样的问题："></a>所以才引入了“generator”来解决这样的问题：</h2><pre><code>function getLines($file) {    $f = fopen($file, &#39;r&#39;);    if (!$f) throw new Exception();    while ($line = fgets($f)) {        yield $line;    }    fclose($f);}</code></pre><p>看上去是不是简单多了？实际上是相同功能不同语法，只是用了新的关键词yield。</p><h1 id="它是如何工作的？"><a href="#它是如何工作的？" class="headerlink" title="它是如何工作的？"></a>它是如何工作的？</h1><p>这里要注意的重要一点是函数的返回值已经改变。 yield关键字的存在使PHP引擎返回特殊Generator类的实例。 该类实现了Iterator，因此可以直接在迭代上下文中使用：</p><pre><code>foreach (getLines(&quot;someFile&quot;) as $line) {    doSomethingWithLine($line);}</code></pre><p>最酷的是我们可以随机构建任何我们想要的代码，只需要 yield 每一步迭代的值即可。那么，具体怎么运行的呢？<br>我们来看一下，当你调用getLines()方法时，PHP会运行代码直到遇到第一个“yield”，这个时候会记住这个值并返回Generator的实例，<br>然后当next()被Generator对象内部调用的时候，PHP将会继续从上一个“yield”语句处重复运行，直到遇到下一个“yield” 或者 到达方法末尾的return 结束。</p><p>理解了这点之后，下面构建一个有用的生成器：</p><pre><code>function doStuff() {    $last = 0;    $current = 1;    yield 1;    while (true) {        $last = $current - $last;        $current = $last + $current;        yield $current;    }}</code></pre><p>你能看出他是做什么吗？乍一看，像一个死循环，对么？对喽，实际上如果我们想，它确实可以成为一个死循环。<br>但是仔细看看一下，你会发现它其实是用最简单的办法实现了一个“斐波那契数列”，那么我们就测试一下这个数列的计算与使用公式的计算进行比较，看他们的差距如何，上示例代码：<br>下面使用Generator构建的数列，可以测试内存使用和计算需要的时间</p><pre><code>&#x2F;&#x2F; Commond line params$var = $argv[1];&#x2F;&#x2F; Generator way ,since 5.5.0$memoryStart = memory_get_usage();$timeStart = microtime(true);function doStuff() {    $last = 0;    yield 0;    $current = 1;    yield 1;    while (true) {            $current = $last + $current;            $last = $current - $last;            yield $current;    }}&#x2F;&#x2F; Iterate the generator way,save memoryforeach(doStuff() as $key =&gt; $number){    if($key == $var)    {        echo $number;        break;    }}$memoryEnd = memory_get_usage();$timeEnd = microtime(true);echo &#39;-Memory Usage:&#39;,$memoryEnd-$memoryStart,&#39;-Runtime:&#39;,$timeEnd-$timeStart,PHP_EOL;</code></pre><p>再来看看直接使用数学公式，递归的方式进行计算(与循环的方式类似)的运行情况：</p><pre><code>&#x2F;&#x2F; Simple traditional way, huge memory usage.crash when number larger$memoryStart2 = memory_get_usage();$timeStart2 = microtime(true);function foo($i){    if($i == 0) return 0;    if($i == 1) return 1;    return foo($i-2)+foo($i-1);}$number = foo($var);$memoryEnd2 = memory_get_usage();$timeEnd2 = microtime(true);echo $number, &#39;-Memory Usage:&#39;,($memoryEnd2-$memoryStart2),&#39;-Runtime:&#39;,$timeEnd2-$timeStart2,PHP_EOL;echo &#39;Recursive call calculate consume Time is &#39;,($timeEnd2-$timeStart2) &#x2F; ($timeEnd-$timeStart),&#39; times of Generator iterator!!&#39;,PHP_EOL;</code></pre><p>可见在某些场景下，效果巨大差距非常明显，但是必须记住的是，Generator并非Iterator的替代，而只是一种简便或者更有效的实现方式。<br>Iterator 仍然有强大的用途，特别是在集合类中，需要维护一系列明确的对象状态的场景是极其有效地。</p><h2 id="一个更复杂的例子"><a href="#一个更复杂的例子" class="headerlink" title="一个更复杂的例子"></a>一个更复杂的例子</h2><p>比方说我们要创建一个用户空间的ArrayObject实现，不是实现迭代器，并且需要我们手动处理数组迭代，我们可以用点儿小技巧。<br>我们可以通过实现IteratorAggregate接口来构建我们自己的生成器，该接口要求一个单一方法：getIterator()。<br>因为生成器方法返回一个实现了Iterator的对象，所以我们可以通过实现接口的方法来构造我们自己的生成器！想象一下下面这个简单的类：<br><pre><code>class ArrayObject implements IteratorAggregate {    protected $array;    public function __construct(array $array) {        $this-&gt;array = $array;    }    public function getIterator() {        foreach ($this-&gt;array as $key =&gt; $value) {            yield $key =&gt; $value;        }    }}</code></pre></p><p>如此简单的实现，很容易掌握，并且如果你注意的话，我们可以使用通常的key语法，返回一个自定义的key。这里的重点是它带有一个复杂的任务(明确的存储状态)并且我们显式的完成它，用语言优势完成它。这样我们可以专注于完成业务，而避免去尝试一大堆的模板代码，但我们没有完成…</p><p>发送反馈数据<br>我们同样可以选择使用generator返回数据。yield方法也可以返回一个value值，即使用send()发给generator的值。这可能会比较方便，取决于我们想要做什么。所以，我们来看一个例子。比如说，我们要记录一堆日志数据。当然了，我们可以写一个功能齐全的重量级日志类，分别维护各种状态实现(我们一定可以很好地完成)，但是这里我们可以简单的使用一个生成器(Generator)完成：<br><pre><code>function createLog($file) {    $f = fopen($file, &#39;a&#39;);    while (true) {        $line = yield;        fwrite($f, $line);    }}$log = createLog($file);$log-&gt;send(&quot;First&quot;);$log-&gt;send(&quot;Second&quot;);$log-&gt;send(&quot;Third&quot;);</code></pre></p><p>及其简单…可能确实太简单的原因，那么我们看一个复杂一点儿的例子。一个协同程序(协同程序共同工作，来产生往复控制)。比如说，我们要构造一个队列批处理系统，可以提取数据，可以批量发送往返数据。就如同读取二进制流是反复读取指定长度的信息一样。我们可以手动将它们链接起来，或者我们创建一些列的生成器来实现：</p><h1 id="参考列表："><a href="#参考列表：" class="headerlink" title="参考列表："></a>参考列表：</h1><p>PHP官方文档：<a href="http://php.net/manual/zh/language.generators.overview.php" target="_blank" rel="noopener">http://php.net/manual/zh/language.generators.overview.php</a><br>Anthony Ferrara博客：<a href="http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html" target="_blank" rel="noopener">http://blog.ircmaxell.com/2012/07/what-generators-can-do-for-you.html</a><br>PHP 5.5: The Power to Yield: <a href="http://cogitolearning.co.uk/?p=821" target="_blank" rel="noopener">http://cogitolearning.co.uk/?p=821</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 迭代器 </tag>
            
            <tag> 生成器 </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
